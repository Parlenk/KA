const mongoose = require('mongoose');\n\n// Schema for asset metadata and organization\nconst AssetMetadataSchema = new mongoose.Schema({\n  assetId: { type: String, required: true, unique: true },\n  userId: { type: String, required: true, index: true },\n  \n  // File information\n  filename: { type: String, required: true },\n  originalName: { type: String, required: true },\n  mimeType: { type: String, required: true },\n  size: { type: Number, required: true }, // bytes\n  \n  // URLs\n  url: { type: String, required: true },\n  thumbnailUrl: String,\n  previewUrl: String,\n  \n  // Media dimensions\n  width: Number,\n  height: Number,\n  duration: Number, // for video/audio in seconds\n  \n  // Asset type and category\n  type: {\n    type: String,\n    required: true,\n    enum: ['image', 'video', 'audio', 'font', 'template', 'icon'],\n    index: true\n  },\n  \n  category: {\n    type: String,\n    enum: ['photo', 'illustration', 'icon', 'background', 'pattern', 'texture', 'logo', 'other'],\n    default: 'other'\n  },\n  \n  // Organization\n  tags: [{ type: String, index: true }],\n  folder: { type: String, default: 'uploads' },\n  collection: String, // User-defined collections\n  \n  // AI-generated metadata\n  aiAnalysis: {\n    colors: [{\n      hex: String,\n      percentage: Number,\n      name: String\n    }],\n    objects: [{\n      name: String,\n      confidence: Number,\n      boundingBox: {\n        x: Number,\n        y: Number,\n        width: Number,\n        height: Number\n      }\n    }],\n    style: {\n      artistic: Boolean,\n      photographic: Boolean,\n      minimalist: Boolean,\n      vintage: Boolean,\n      modern: Boolean\n    },\n    mood: {\n      happy: Number,\n      serious: Number,\n      energetic: Number,\n      calm: Number,\n      professional: Number\n    },\n    keywords: [String]\n  },\n  \n  // Usage tracking\n  usage: {\n    totalUses: { type: Number, default: 0 },\n    designsUsedIn: [String], // Array of design IDs\n    lastUsed: Date,\n    popularityScore: { type: Number, default: 0 }\n  },\n  \n  // Processing status\n  processing: {\n    status: {\n      type: String,\n      enum: ['pending', 'processing', 'completed', 'failed'],\n      default: 'pending'\n    },\n    thumbnailGenerated: { type: Boolean, default: false },\n    aiAnalyzed: { type: Boolean, default: false },\n    optimized: { type: Boolean, default: false },\n    error: String\n  },\n  \n  // Quality and technical info\n  quality: {\n    score: { type: Number, min: 0, max: 100 }, // 0-100 quality score\n    resolution: String, // 'low', 'medium', 'high', 'ultra'\n    compression: String, // 'none', 'low', 'medium', 'high'\n    hasTransparency: Boolean,\n    colorSpace: String, // 'sRGB', 'AdobeRGB', 'CMYK'\n    dpi: Number\n  },\n  \n  // Copyright and licensing\n  license: {\n    type: {\n      type: String,\n      enum: ['public-domain', 'creative-commons', 'stock', 'premium', 'user-upload'],\n      default: 'user-upload'\n    },\n    attribution: String,\n    commercial: { type: Boolean, default: true },\n    modification: { type: Boolean, default: true },\n    source: String,\n    purchaseDate: Date,\n    licenseKey: String\n  },\n  \n  // Search optimization\n  searchKeywords: [String], // Processed keywords for search\n  searchVector: [Number], // Vector embedding for semantic search\n  \n  // Timestamps\n  createdAt: { type: Date, default: Date.now, index: true },\n  updatedAt: { type: Date, default: Date.now },\n  lastAccessed: { type: Date, default: Date.now }\n}, {\n  collection: 'assetmetadata',\n  timestamps: true\n});\n\n// Indexes for performance\nAssetMetadataSchema.index({ userId: 1, type: 1 });\nAssetMetadataSchema.index({ userId: 1, category: 1 });\nAssetMetadataSchema.index({ tags: 1 });\nAssetMetadataSchema.index({ 'aiAnalysis.keywords': 1 });\nAssetMetadataSchema.index({ searchKeywords: 1 });\nAssetMetadataSchema.index({ 'usage.popularityScore': -1 });\nAssetMetadataSchema.index({ 'usage.lastUsed': -1 });\nAssetMetadataSchema.index({ size: 1 });\nAssetMetadataSchema.index({ width: 1, height: 1 });\n\n// Text index for search\nAssetMetadataSchema.index({\n  filename: 'text',\n  originalName: 'text',\n  tags: 'text',\n  'aiAnalysis.keywords': 'text',\n  searchKeywords: 'text'\n}, {\n  weights: {\n    filename: 10,\n    tags: 8,\n    'aiAnalysis.keywords': 6,\n    searchKeywords: 4,\n    originalName: 2\n  },\n  name: 'asset_search_index'\n});\n\n// Pre-save middleware\nAssetMetadataSchema.pre('save', function(next) {\n  // Update search keywords\n  this.searchKeywords = [\n    ...this.tags,\n    ...(this.aiAnalysis?.keywords || []),\n    this.category,\n    this.type\n  ].filter(Boolean);\n  \n  // Calculate popularity score\n  const daysSinceCreation = Math.max(1, (Date.now() - this.createdAt) / (1000 * 60 * 60 * 24));\n  const usageFrequency = this.usage.totalUses / daysSinceCreation;\n  const recencyBoost = this.usage.lastUsed ? Math.max(0, 30 - (Date.now() - this.usage.lastUsed) / (1000 * 60 * 60 * 24)) : 0;\n  \n  this.usage.popularityScore = Math.round((usageFrequency * 10) + (recencyBoost * 0.5));\n  \n  next();\n});\n\n// Instance methods\nAssetMetadataSchema.methods.trackUsage = function(designId) {\n  this.usage.totalUses += 1;\n  this.usage.lastUsed = new Date();\n  this.lastAccessed = new Date();\n  \n  if (designId && !this.usage.designsUsedIn.includes(designId)) {\n    this.usage.designsUsedIn.push(designId);\n  }\n  \n  return this.save();\n};\n\nAssetMetadataSchema.methods.addTags = function(newTags) {\n  const existingTags = new Set(this.tags);\n  const tagsToAdd = newTags.filter(tag => !existingTags.has(tag));\n  \n  this.tags.push(...tagsToAdd);\n  return this.save();\n};\n\nAssetMetadataSchema.methods.updateAIAnalysis = function(analysis) {\n  this.aiAnalysis = { ...this.aiAnalysis, ...analysis };\n  this.processing.aiAnalyzed = true;\n  this.processing.status = 'completed';\n  \n  return this.save();\n};\n\nAssetMetadataSchema.methods.generateThumbnail = function(thumbnailUrl) {\n  this.thumbnailUrl = thumbnailUrl;\n  this.processing.thumbnailGenerated = true;\n  \n  return this.save();\n};\n\n// Static methods\nAssetMetadataSchema.statics.findByUser = function(userId, options = {}) {\n  const {\n    type,\n    category,\n    tags,\n    limit = 20,\n    skip = 0,\n    sort = '-createdAt'\n  } = options;\n  \n  const query = { userId };\n  \n  if (type) query.type = type;\n  if (category) query.category = category;\n  if (tags && tags.length > 0) query.tags = { $in: tags };\n  \n  return this.find(query)\n    .sort(sort)\n    .limit(limit)\n    .skip(skip)\n    .select('-searchVector'); // Exclude vector data for performance\n};\n\nAssetMetadataSchema.statics.searchAssets = function(userId, searchTerm, options = {}) {\n  const {\n    type,\n    category,\n    limit = 20,\n    skip = 0\n  } = options;\n  \n  const query = {\n    userId,\n    $text: { $search: searchTerm }\n  };\n  \n  if (type) query.type = type;\n  if (category) query.category = category;\n  \n  return this.find(query, {\n    score: { $meta: 'textScore' }\n  })\n    .sort({ score: { $meta: 'textScore' }, 'usage.popularityScore': -1 })\n    .limit(limit)\n    .skip(skip)\n    .select('-searchVector');\n};\n\nAssetMetadataSchema.statics.findSimilar = function(assetId, limit = 10) {\n  // This would implement similarity search based on AI analysis\n  // For now, return assets with similar tags\n  return this.findById(assetId).then(asset => {\n    if (!asset) throw new Error('Asset not found');\n    \n    return this.find({\n      _id: { $ne: assetId },\n      userId: asset.userId,\n      type: asset.type,\n      tags: { $in: asset.tags }\n    })\n      .sort({ 'usage.popularityScore': -1 })\n      .limit(limit)\n      .select('-searchVector');\n  });\n};\n\nAssetMetadataSchema.statics.getPopular = function(userId, type = null, limit = 20) {\n  const query = { userId };\n  if (type) query.type = type;\n  \n  return this.find(query)\n    .sort({ 'usage.popularityScore': -1, 'usage.totalUses': -1 })\n    .limit(limit)\n    .select('-searchVector');\n};\n\nAssetMetadataSchema.statics.getRecent = function(userId, type = null, limit = 20) {\n  const query = { userId };\n  if (type) query.type = type;\n  \n  return this.find(query)\n    .sort({ createdAt: -1 })\n    .limit(limit)\n    .select('-searchVector');\n};\n\nAssetMetadataSchema.statics.getUsageStats = function(userId) {\n  return this.aggregate([\n    { $match: { userId } },\n    {\n      $group: {\n        _id: '$type',\n        count: { $sum: 1 },\n        totalSize: { $sum: '$size' },\n        totalUses: { $sum: '$usage.totalUses' },\n        avgPopularity: { $avg: '$usage.popularityScore' }\n      }\n    },\n    { $sort: { count: -1 } }\n  ]);\n};\n\nAssetMetadataSchema.statics.cleanup = function(userId, daysOld = 90) {\n  const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1000);\n  \n  return this.deleteMany({\n    userId,\n    'usage.totalUses': 0,\n    createdAt: { $lt: cutoffDate }\n  });\n};\n\nmodule.exports = mongoose.model('AssetMetadata', AssetMetadataSchema);