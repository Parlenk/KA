const mongoose = require('mongoose');\n\n// Schema for canvas history/versioning\nconst CanvasHistorySchema = new mongoose.Schema({\n  canvasId: { type: String, required: true, index: true },\n  designSetId: { type: String, required: true, index: true },\n  userId: { type: String, required: true, index: true },\n  \n  // Version info\n  version: { type: Number, required: true },\n  parentVersion: { type: Number },\n  \n  // Snapshot data\n  data: {\n    width: Number,\n    height: Number,\n    backgroundColor: String,\n    backgroundImage: String,\n    backgroundType: String,\n    objects: [mongoose.Schema.Types.Mixed],\n    settings: mongoose.Schema.Types.Mixed,\n    metadata: mongoose.Schema.Types.Mixed\n  },\n  \n  // Change tracking\n  changeType: {\n    type: String,\n    enum: ['create', 'update', 'delete', 'bulk_update', 'auto_save', 'manual_save'],\n    default: 'update'\n  },\n  \n  changeSummary: {\n    objectsAdded: { type: Number, default: 0 },\n    objectsModified: { type: Number, default: 0 },\n    objectsDeleted: { type: Number, default: 0 },\n    propertiesChanged: [String],\n    description: String\n  },\n  \n  // Metadata\n  label: String, // User-defined checkpoint label\n  isCheckpoint: { type: Boolean, default: false },\n  isMilestone: { type: Boolean, default: false },\n  \n  // Size tracking\n  dataSize: { type: Number }, // Size in bytes\n  compressed: { type: Boolean, default: false },\n  \n  createdAt: { type: Date, default: Date.now, index: true },\n  expiresAt: { type: Date, index: { expireAfterSeconds: 0 } } // TTL for auto-cleanup\n}, {\n  collection: 'canvashistory',\n  timestamps: false // We handle createdAt manually\n});\n\n// Compound indexes for efficient queries\nCanvasHistorySchema.index({ canvasId: 1, version: -1 });\nCanvasHistorySchema.index({ canvasId: 1, createdAt: -1 });\nCanvasHistorySchema.index({ designSetId: 1, createdAt: -1 });\nCanvasHistorySchema.index({ userId: 1, createdAt: -1 });\nCanvasHistorySchema.index({ isCheckpoint: 1, canvasId: 1 });\nCanvasHistorySchema.index({ isMilestone: 1, designSetId: 1 });\n\n// Pre-save middleware\nCanvasHistorySchema.pre('save', function(next) {\n  // Calculate data size if not set\n  if (!this.dataSize && this.data) {\n    this.dataSize = JSON.stringify(this.data).length;\n  }\n  \n  // Set expiration for non-milestone versions (30 days)\n  if (!this.isMilestone && !this.isCheckpoint && !this.expiresAt) {\n    this.expiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30 days\n  }\n  \n  next();\n});\n\n// Instance methods\nCanvasHistorySchema.methods.createRestorePoint = async function() {\n  const CanvasData = mongoose.model('CanvasData');\n  \n  // Update current canvas data with this version\n  const restored = await CanvasData.findOneAndUpdate(\n    { canvasId: this.canvasId },\n    {\n      ...this.data,\n      version: this.version,\n      lastEditedBy: this.userId,\n      updatedAt: new Date()\n    },\n    { new: true, upsert: true }\n  );\n  \n  return restored;\n};\n\nCanvasHistorySchema.methods.getDifferences = function(compareVersion) {\n  // This would implement a diff algorithm to show changes between versions\n  // For now, return a simple comparison\n  return {\n    version: this.version,\n    compareVersion,\n    changes: [\n      // Would contain actual diff data\n    ]\n  };\n};\n\n// Static methods\nCanvasHistorySchema.statics.findVersions = function(canvasId, limit = 10) {\n  return this.find({ canvasId })\n    .sort({ version: -1 })\n    .limit(limit)\n    .select('version changeType changeSummary label isCheckpoint isMilestone createdAt dataSize');\n};\n\nCanvasHistorySchema.statics.findCheckpoints = function(canvasId) {\n  return this.find({ \n    canvasId, \n    $or: [{ isCheckpoint: true }, { isMilestone: true }]\n  })\n    .sort({ version: -1 })\n    .select('version label isCheckpoint isMilestone createdAt changeSummary');\n};\n\nCanvasHistorySchema.statics.createCheckpoint = function(canvasId, userId, label) {\n  const CanvasData = mongoose.model('CanvasData');\n  \n  return CanvasData.findOne({ canvasId }).then(canvas => {\n    if (!canvas) throw new Error('Canvas not found');\n    \n    return this.create({\n      canvasId,\n      designSetId: canvas.designSetId,\n      userId,\n      version: canvas.version,\n      data: canvas.toObject(),\n      changeType: 'manual_save',\n      label,\n      isCheckpoint: true,\n      changeSummary: {\n        description: `Manual checkpoint: ${label}`\n      }\n    });\n  });\n};\n\nCanvasHistorySchema.statics.createMilestone = function(designSetId, userId, label) {\n  const CanvasData = mongoose.model('CanvasData');\n  \n  return CanvasData.find({ designSetId }).then(canvases => {\n    const milestones = canvases.map(canvas => ({\n      canvasId: canvas.canvasId,\n      designSetId: canvas.designSetId,\n      userId,\n      version: canvas.version,\n      data: canvas.toObject(),\n      changeType: 'manual_save',\n      label,\n      isMilestone: true,\n      changeSummary: {\n        description: `Milestone: ${label}`\n      }\n    }));\n    \n    return this.insertMany(milestones);\n  });\n};\n\nCanvasHistorySchema.statics.cleanup = function(retentionDays = 30) {\n  const cutoffDate = new Date(Date.now() - retentionDays * 24 * 60 * 60 * 1000);\n  \n  return this.deleteMany({\n    createdAt: { $lt: cutoffDate },\n    isCheckpoint: false,\n    isMilestone: false\n  });\n};\n\nCanvasHistorySchema.statics.getStorageStats = function(canvasId = null) {\n  const matchStage = canvasId ? { $match: { canvasId } } : { $match: {} };\n  \n  return this.aggregate([\n    matchStage,\n    {\n      $group: {\n        _id: canvasId ? '$canvasId' : '$designSetId',\n        totalVersions: { $sum: 1 },\n        totalSize: { $sum: '$dataSize' },\n        checkpoints: {\n          $sum: { $cond: ['$isCheckpoint', 1, 0] }\n        },\n        milestones: {\n          $sum: { $cond: ['$isMilestone', 1, 0] }\n        },\n        oldestVersion: { $min: '$createdAt' },\n        newestVersion: { $max: '$createdAt' }\n      }\n    }\n  ]);\n};\n\nmodule.exports = mongoose.model('CanvasHistory', CanvasHistorySchema);