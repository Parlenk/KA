const CanvasData = require('../models/CanvasData');\nconst CanvasHistory = require('../models/CanvasHistory');\nconst { getMongoService } = require('./mongoService');\n\nclass CanvasService {\n  constructor() {\n    this.mongoService = getMongoService();\n  }\n\n  async ensureConnection() {\n    if (!this.mongoService.isConnected) {\n      await this.mongoService.connect();\n    }\n  }\n\n  // Canvas CRUD operations\n  async createCanvas(canvasData) {\n    await this.ensureConnection();\n    \n    const canvas = new CanvasData({\n      canvasId: canvasData.canvasId,\n      designSetId: canvasData.designSetId,\n      userId: canvasData.userId,\n      width: canvasData.width,\n      height: canvasData.height,\n      backgroundColor: canvasData.backgroundColor || '#ffffff',\n      objects: canvasData.objects || [],\n      settings: canvasData.settings || {},\n      metadata: canvasData.metadata || {}\n    });\n    \n    const savedCanvas = await canvas.save();\n    \n    // Create initial history entry\n    await this.createHistoryEntry(savedCanvas, 'create', 'Canvas created');\n    \n    return savedCanvas;\n  }\n\n  async getCanvas(canvasId, version = null) {\n    await this.ensureConnection();\n    \n    if (version) {\n      // Get specific version from history\n      const historyEntry = await CanvasHistory.findOne({ canvasId, version });\n      if (!historyEntry) {\n        throw new Error('Version not found');\n      }\n      return historyEntry.data;\n    }\n    \n    return await CanvasData.findByCanvasId(canvasId);\n  }\n\n  async updateCanvas(canvasId, updateData, userId, changeDescription = null) {\n    await this.ensureConnection();\n    \n    const canvas = await CanvasData.findByCanvasId(canvasId);\n    if (!canvas) {\n      throw new Error('Canvas not found');\n    }\n    \n    // Store previous state for history\n    const previousVersion = canvas.version;\n    \n    // Update canvas data\n    Object.assign(canvas, updateData);\n    canvas.version += 1;\n    canvas.lastEditedBy = userId;\n    canvas.updatedAt = new Date();\n    \n    const savedCanvas = await canvas.save();\n    \n    // Create history entry\n    await this.createHistoryEntry(\n      savedCanvas, \n      'update', \n      changeDescription || 'Canvas updated',\n      this.calculateChanges(canvas.objects, updateData.objects)\n    );\n    \n    return savedCanvas;\n  }\n\n  async deleteCanvas(canvasId, userId) {\n    await this.ensureConnection();\n    \n    const canvas = await CanvasData.findByCanvasId(canvasId);\n    if (!canvas) {\n      throw new Error('Canvas not found');\n    }\n    \n    // Create final history entry\n    await this.createHistoryEntry(canvas, 'delete', 'Canvas deleted');\n    \n    // Delete canvas and all history\n    await Promise.all([\n      CanvasData.deleteOne({ canvasId }),\n      CanvasHistory.deleteMany({ canvasId })\n    ]);\n    \n    return { success: true, message: 'Canvas deleted' };\n  }\n\n  // Design set operations\n  async getDesignSetCanvases(designSetId) {\n    await this.ensureConnection();\n    return await CanvasData.findByDesignSet(designSetId);\n  }\n\n  async syncDesignSet(designSetId, sourceCanvasId, changes, userId) {\n    await this.ensureConnection();\n    \n    const canvases = await CanvasData.findByDesignSet(designSetId);\n    const updates = [];\n    \n    for (const canvas of canvases) {\n      if (canvas.canvasId !== sourceCanvasId) {\n        // Apply smart resize logic\n        const scaledChanges = this.applySmartResize(changes, canvas);\n        \n        updates.push({\n          canvasId: canvas.canvasId,\n          data: {\n            ...scaledChanges,\n            lastEditedBy: userId,\n            lastSyncedAt: new Date()\n          }\n        });\n      }\n    }\n    \n    if (updates.length > 0) {\n      await CanvasData.bulkSync(updates);\n      \n      // Create history entries for synced canvases\n      const historyPromises = updates.map(update => \n        this.createHistoryEntry(\n          { canvasId: update.canvasId, designSetId, userId },\n          'bulk_update',\n          `Synced from ${sourceCanvasId}`\n        )\n      );\n      \n      await Promise.all(historyPromises);\n    }\n    \n    return { synced: updates.length, canvases: updates.map(u => u.canvasId) };\n  }\n\n  // History and versioning\n  async createHistoryEntry(canvas, changeType, description, changeSummary = {}) {\n    await this.ensureConnection();\n    \n    return await CanvasHistory.create({\n      canvasId: canvas.canvasId,\n      designSetId: canvas.designSetId,\n      userId: canvas.lastEditedBy || canvas.userId,\n      version: canvas.version,\n      data: canvas.toObject ? canvas.toObject() : canvas,\n      changeType,\n      changeSummary: {\n        description,\n        ...changeSummary\n      }\n    });\n  }\n\n  async getCanvasHistory(canvasId, limit = 10) {\n    await this.ensureConnection();\n    return await CanvasHistory.findVersions(canvasId, limit);\n  }\n\n  async createCheckpoint(canvasId, userId, label) {\n    await this.ensureConnection();\n    return await CanvasHistory.createCheckpoint(canvasId, userId, label);\n  }\n\n  async restoreVersion(canvasId, version, userId) {\n    await this.ensureConnection();\n    \n    const historyEntry = await CanvasHistory.findOne({ canvasId, version });\n    if (!historyEntry) {\n      throw new Error('Version not found');\n    }\n    \n    const restored = await historyEntry.createRestorePoint();\n    \n    // Create history entry for restoration\n    await this.createHistoryEntry(\n      restored,\n      'update',\n      `Restored to version ${version}`\n    );\n    \n    return restored;\n  }\n\n  // Real-time collaboration\n  async lockCanvas(canvasId, userId, duration = 30000) {\n    await this.ensureConnection();\n    \n    const canvas = await CanvasData.findByCanvasId(canvasId);\n    if (!canvas) {\n      throw new Error('Canvas not found');\n    }\n    \n    if (canvas.lockedBy && canvas.lockedBy !== userId) {\n      const lockAge = Date.now() - canvas.lockedAt.getTime();\n      if (lockAge < duration) {\n        throw new Error('Canvas is locked by another user');\n      }\n    }\n    \n    canvas.lockedBy = userId;\n    canvas.lockedAt = new Date();\n    \n    return await canvas.save();\n  }\n\n  async unlockCanvas(canvasId, userId) {\n    await this.ensureConnection();\n    \n    const canvas = await CanvasData.findByCanvasId(canvasId);\n    if (!canvas) {\n      throw new Error('Canvas not found');\n    }\n    \n    if (canvas.lockedBy !== userId) {\n      throw new Error('Canvas is not locked by this user');\n    }\n    \n    canvas.lockedBy = null;\n    canvas.lockedAt = null;\n    \n    return await canvas.save();\n  }\n\n  // Search and analytics\n  async searchCanvases(userId, searchTerm, filters = {}) {\n    await this.ensureConnection();\n    \n    const query = { userId };\n    \n    if (searchTerm) {\n      query.$or = [\n        { 'metadata.name': { $regex: searchTerm, $options: 'i' } },\n        { 'metadata.description': { $regex: searchTerm, $options: 'i' } },\n        { 'metadata.tags': { $in: [new RegExp(searchTerm, 'i')] } }\n      ];\n    }\n    \n    if (filters.designSetId) query.designSetId = filters.designSetId;\n    if (filters.width) query.width = filters.width;\n    if (filters.height) query.height = filters.height;\n    \n    return await CanvasData.find(query)\n      .sort({ updatedAt: -1 })\n      .limit(filters.limit || 20)\n      .skip(filters.skip || 0);\n  }\n\n  async getCanvasStats(canvasId) {\n    await this.ensureConnection();\n    \n    const [canvas, historyStats] = await Promise.all([\n      CanvasData.findByCanvasId(canvasId),\n      CanvasHistory.getStorageStats(canvasId)\n    ]);\n    \n    if (!canvas) {\n      throw new Error('Canvas not found');\n    }\n    \n    return {\n      canvas: {\n        version: canvas.version,\n        objectCount: canvas.metadata.stats.objectCount,\n        lastUpdated: canvas.updatedAt,\n        size: JSON.stringify(canvas).length\n      },\n      history: historyStats[0] || {\n        totalVersions: 0,\n        totalSize: 0,\n        checkpoints: 0,\n        milestones: 0\n      }\n    };\n  }\n\n  // Utility methods\n  applySmartResize(changes, targetCanvas) {\n    const scaleFactor = targetCanvas.width / changes.sourceWidth || 1;\n    \n    if (!changes.objects) return changes;\n    \n    const scaledObjects = changes.objects.map(obj => ({\n      ...obj,\n      left: obj.left * scaleFactor,\n      top: obj.top * scaleFactor,\n      width: obj.width * scaleFactor,\n      height: obj.height * scaleFactor,\n      fontSize: obj.fontSize ? obj.fontSize * scaleFactor : obj.fontSize\n    }));\n    \n    return {\n      ...changes,\n      objects: scaledObjects\n    };\n  }\n\n  calculateChanges(oldObjects = [], newObjects = []) {\n    const oldIds = new Set(oldObjects.map(obj => obj.id));\n    const newIds = new Set(newObjects.map(obj => obj.id));\n    \n    const added = newObjects.filter(obj => !oldIds.has(obj.id));\n    const deleted = oldObjects.filter(obj => !newIds.has(obj.id));\n    const modified = newObjects.filter(obj => {\n      const oldObj = oldObjects.find(o => o.id === obj.id);\n      return oldObj && JSON.stringify(oldObj) !== JSON.stringify(obj);\n    });\n    \n    return {\n      objectsAdded: added.length,\n      objectsModified: modified.length,\n      objectsDeleted: deleted.length,\n      propertiesChanged: this.getChangedProperties(oldObjects, newObjects)\n    };\n  }\n\n  getChangedProperties(oldObjects, newObjects) {\n    const changedProps = new Set();\n    \n    newObjects.forEach(newObj => {\n      const oldObj = oldObjects.find(obj => obj.id === newObj.id);\n      if (oldObj) {\n        Object.keys(newObj).forEach(key => {\n          if (JSON.stringify(oldObj[key]) !== JSON.stringify(newObj[key])) {\n            changedProps.add(key);\n          }\n        });\n      }\n    });\n    \n    return Array.from(changedProps);\n  }\n\n  // Cleanup and maintenance\n  async cleanupOldVersions(retentionDays = 30) {\n    await this.ensureConnection();\n    return await CanvasHistory.cleanup(retentionDays);\n  }\n\n  async optimizeStorage() {\n    await this.ensureConnection();\n    \n    // This would implement storage optimization strategies\n    // For now, just return stats\n    return {\n      message: 'Storage optimization completed',\n      freed: 0\n    };\n  }\n}\n\n// Singleton instance\nlet canvasService;\n\nfunction getCanvasService() {\n  if (!canvasService) {\n    canvasService = new CanvasService();\n  }\n  return canvasService;\n}\n\nmodule.exports = {\n  CanvasService,\n  getCanvasService\n};